<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC AIäºˆæ¸¬ãƒãƒ£ãƒ¼ãƒˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        h1 {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .price-info {
            text-align: right;
        }
        
        .current-price {
            font-size: 1.8rem;
            font-weight: bold;
            color: #00d4aa;
        }
        
        .timestamp {
            font-size: 0.85rem;
            color: #888;
        }
        
        /* æ—¥ä»˜ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ */
        .date-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #16213e;
            border-radius: 8px;
        }
        
        .nav-btn {
            background: #0f3460;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: background 0.2s, opacity 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .nav-btn:hover:not(:disabled) {
            background: #1a5276;
        }
        
        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .current-date {
            font-size: 1.2rem;
            font-weight: bold;
            min-width: 150px;
            text-align: center;
        }
        
        .current-date.is-latest {
            color: #00d4aa;
        }
        
        .current-date.is-latest::after {
            content: ' (æœ€æ–°)';
            font-size: 0.8rem;
            color: #888;
        }
        
        #chart-container {
            width: 100%;
            height: 500px;
            background: #16213e;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .patterns-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .pattern-card {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #666;
        }
        
        .pattern-card.bullish {
            border-left-color: #00d4aa;
        }
        
        .pattern-card.bearish {
            border-left-color: #ff6b6b;
        }
        
        .pattern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .pattern-rank {
            background: #0f3460;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.85rem;
        }
        
        .pattern-name {
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .pattern-probability {
            font-size: 1.3rem;
            font-weight: bold;
        }
        
        .bullish .pattern-probability {
            color: #00d4aa;
        }
        
        .bearish .pattern-probability {
            color: #ff6b6b;
        }
        
        .pattern-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 10px 0;
            font-size: 0.9rem;
        }
        
        .detail-item {
            display: flex;
            justify-content: space-between;
        }
        
        .detail-label {
            color: #888;
        }
        
        .pattern-reasoning {
            font-size: 0.85rem;
            color: #aaa;
            line-height: 1.5;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
        }
        
        .summary-box {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .summary-box h3 {
            margin-bottom: 10px;
            color: #00d4aa;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 300px;
            color: #888;
        }
        
        .error {
            background: #3d1f1f;
            padding: 15px;
            border-radius: 8px;
            color: #ff6b6b;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.85rem;
        }
        
        footer a {
            color: #00d4aa;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸª™ BTC AIäºˆæ¸¬ãƒãƒ£ãƒ¼ãƒˆ</h1>
            <div class="price-info">
                <div class="current-price" id="current-price">--</div>
                <div class="timestamp" id="timestamp">--</div>
            </div>
        </header>
        
        <!-- æ—¥ä»˜ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ -->
        <div class="date-nav">
            <button class="nav-btn" id="prev-btn" onclick="navigatePrediction(-1)">
                â† å‰æ—¥
            </button>
            <div class="current-date" id="current-date">--</div>
            <button class="nav-btn" id="next-btn" onclick="navigatePrediction(1)">
                ç¿Œæ—¥ â†’
            </button>
        </div>
        
        <div id="chart-container"></div>
        
        <div class="summary-box" id="summary-box">
            <h3>ğŸ“Š åˆ†æã‚µãƒãƒªãƒ¼</h3>
            <p id="summary-text">èª­ã¿è¾¼ã¿ä¸­...</p>
        </div>
        
        <h2 style="margin-bottom: 15px;">ğŸ“ˆ äºˆæ¸¬ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç¢ºç‡é †ï¼‰</h2>
        <div class="patterns-grid" id="patterns-grid">
            <div class="loading">ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
        </div>
        
        <footer>
            <p>Powered by AI Analysis | <a href="https://x.com/DriftSeiya" target="_blank">@DriftSeiya</a></p>
            <p>â€» ã“ã®äºˆæ¸¬ã¯å‚è€ƒæƒ…å ±ã§ã‚ã‚Šã€æŠ•è³‡åˆ¤æ–­ã®è²¬ä»»ã¯åˆ©ç”¨è€…ã«ã‚ã‚Šã¾ã™ã€‚</p>
        </footer>
    </div>
    
    <script src="lightweight-charts.js"></script>
    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let chart = null;
        let candleSeries = null;
        let predictionLines = [];
        let availableDates = [];
        let currentDateIndex = 0;
        let latestPrediction = null;
        
        // æ—¥ä»˜ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        function formatDate(dateStr) {
            const date = new Date(dateStr);
            return date.toLocaleDateString('ja-JP', { 
                year: 'numeric', 
                month: 'numeric', 
                day: 'numeric' 
            });
        }
        
        // æ—¥ä»˜ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
        function getDateString(date) {
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // äºˆæ¸¬ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        async function navigatePrediction(direction) {
            const newIndex = currentDateIndex + direction;
            
            if (newIndex < 0 || newIndex >= availableDates.length) {
                return;
            }
            
            currentDateIndex = newIndex;
            const dateStr = availableDates[currentDateIndex];
            
            // äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            let prediction;
            if (currentDateIndex === 0) {
                prediction = latestPrediction;
            } else {
                prediction = await fetchPredictionByDate(dateStr);
            }
            
            if (prediction) {
                updateDisplay(prediction);
            }
            
            updateNavButtons();
        }
        
        // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
        function updateNavButtons() {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const dateDisplay = document.getElementById('current-date');
            
            prevBtn.disabled = currentDateIndex >= availableDates.length - 1;
            nextBtn.disabled = currentDateIndex <= 0;
            
            const currentDate = availableDates[currentDateIndex];
            dateDisplay.textContent = formatDate(currentDate);
            
            if (currentDateIndex === 0) {
                dateDisplay.classList.add('is-latest');
            } else {
                dateDisplay.classList.remove('is-latest');
            }
        }
        
        // æ—¥ä»˜åˆ¥ã®äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        async function fetchPredictionByDate(dateStr) {
            try {
                const response = await fetch(`predictions/${dateStr}.json?` + Date.now());
                if (!response.ok) return null;
                return await response.json();
            } catch (error) {
                console.error('Failed to fetch prediction:', error);
                return null;
            }
        }
        
        // åˆ©ç”¨å¯èƒ½ãªæ—¥ä»˜ä¸€è¦§ã‚’å–å¾—
        async function fetchAvailableDates() {
            try {
                const response = await fetch('predictions/index.json?' + Date.now());
                if (!response.ok) {
                    // index.jsonãŒãªã„å ´åˆã¯ä»Šæ—¥ã®æ—¥ä»˜ã®ã¿
                    return [getDateString(new Date())];
                }
                const data = await response.json();
                return data.dates || [getDateString(new Date())];
            } catch (error) {
                console.error('Failed to fetch available dates:', error);
                return [getDateString(new Date())];
            }
        }
        
        // äºˆæ¸¬ãƒ©ã‚¤ãƒ³ã‚’ã‚¯ãƒªã‚¢
        function clearPredictionLines() {
            predictionLines.forEach(line => {
                chart.removeSeries(line);
            });
            predictionLines = [];
        }
        
        // äºˆæ¸¬ãƒ©ã‚¤ãƒ³ã‚’è¿½åŠ 
        function addPredictionLines(patterns, currentPrice) {
            clearPredictionLines();
            
            patterns.slice(0, 5).forEach((pattern, index) => {
                const color = pattern.direction === 'bullish' ? '#00d4aa' : '#ff6b6b';
                
                if (pattern.target_price) {
                    const lineSeries = chart.addLineSeries({
                        color: color,
                        lineWidth: 2,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        priceLineVisible: false,
                        lastValueVisible: true,
                        title: '#' + pattern.rank + ' ' + pattern.pattern_name,
                    });
                    
                    const now = Math.floor(Date.now() / 1000);
                    const future = now + 14 * 24 * 60 * 60;
                    
                    lineSeries.setData([
                        { time: now, value: currentPrice },
                        { time: future, value: pattern.target_price },
                    ]);
                    
                    predictionLines.push(lineSeries);
                }
            });
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
        function renderPatternCards(patterns) {
            const grid = document.getElementById('patterns-grid');
            grid.innerHTML = '';
            
            patterns.forEach(pattern => {
                const card = document.createElement('div');
                card.className = 'pattern-card ' + pattern.direction;
                
                const emoji = pattern.direction === 'bullish' ? 'ğŸ“ˆ' : 'ğŸ“‰';
                const prob = (pattern.probability * 100).toFixed(0);
                const targetPrice = pattern.target_price ? '$' + pattern.target_price.toLocaleString() : '--';
                const entryPrice = pattern.key_levels && pattern.key_levels.entry ? '$' + pattern.key_levels.entry.toLocaleString() : '--';
                const stopLoss = pattern.key_levels && pattern.key_levels.stop_loss ? '$' + pattern.key_levels.stop_loss.toLocaleString() : '--';
                
                card.innerHTML = 
                    '<div class="pattern-header">' +
                        '<span class="pattern-rank">#' + pattern.rank + '</span>' +
                        '<span class="pattern-name">' + emoji + ' ' + pattern.pattern_name + '</span>' +
                        '<span class="pattern-probability">' + prob + '%</span>' +
                    '</div>' +
                    '<div class="pattern-details">' +
                        '<div class="detail-item"><span class="detail-label">ç›®æ¨™ä¾¡æ ¼</span><span>' + targetPrice + '</span></div>' +
                        '<div class="detail-item"><span class="detail-label">æœŸé–“</span><span>' + (pattern.timeframe || '--') + '</span></div>' +
                        '<div class="detail-item"><span class="detail-label">ã‚¨ãƒ³ãƒˆãƒªãƒ¼</span><span>' + entryPrice + '</span></div>' +
                        '<div class="detail-item"><span class="detail-label">ã‚¹ãƒˆãƒƒãƒ—ãƒ­ã‚¹</span><span>' + stopLoss + '</span></div>' +
                    '</div>' +
                    '<div class="pattern-reasoning">' + (pattern.reasoning || '') + '</div>';
                
                grid.appendChild(card);
            });
        }
        
        // è¡¨ç¤ºã‚’æ›´æ–°
        function updateDisplay(prediction) {
            if (!prediction) return;
            
            document.getElementById('current-price').textContent = 
                '$' + (prediction.current_price || 0).toLocaleString();
            
            if (prediction.timestamp) {
                const date = new Date(prediction.timestamp);
                document.getElementById('timestamp').textContent = 
                    'åˆ†ææ—¥æ™‚: ' + date.toLocaleString('ja-JP');
            }
            
            document.getElementById('summary-text').textContent = 
                prediction.summary || 'åˆ†æãƒ‡ãƒ¼ã‚¿ãªã—';
            
            if (prediction.patterns && prediction.patterns.length > 0) {
                renderPatternCards(prediction.patterns);
                addPredictionLines(prediction.patterns, prediction.current_price);
            }
        }
        
        // Bybitã‹ã‚‰ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        async function fetchCandleData() {
            try {
                const response = await fetch(
                    'https://api.bybit.com/v5/market/kline?category=spot&symbol=BTCUSDT&interval=D&limit=100'
                );
                const data = await response.json();
                
                if (data.retCode === 0) {
                    const candles = data.result.list.map(function(item) {
                        return {
                            time: parseInt(item[0]) / 1000,
                            open: parseFloat(item[1]),
                            high: parseFloat(item[2]),
                            low: parseFloat(item[3]),
                            close: parseFloat(item[4]),
                        };
                    }).reverse();
                    
                    candleSeries.setData(candles);
                    return candles[candles.length - 1].close;
                }
            } catch (error) {
                console.error('Failed to fetch candle data:', error);
            }
            return null;
        }
        
        // æœ€æ–°ã®äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        async function fetchLatestPrediction() {
            try {
                const response = await fetch('prediction.json?' + Date.now());
                if (!response.ok) throw new Error('Prediction data not found');
                return await response.json();
            } catch (error) {
                console.error('Failed to fetch prediction data:', error);
                return null;
            }
        }
        
        // åˆæœŸåŒ–
        async function init() {
            const chartContainer = document.getElementById('chart-container');
            
            // ãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿ç¢ºèª
            if (typeof LightweightCharts === 'undefined') {
                document.getElementById('patterns-grid').innerHTML = 
                    '<div class="error">ãƒãƒ£ãƒ¼ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</div>';
                return;
            }
            
            // ãƒãƒ£ãƒ¼ãƒˆåˆæœŸåŒ–
            chart = LightweightCharts.createChart(chartContainer, {
                layout: {
                    background: { color: '#16213e' },
                    textColor: '#d1d4dc',
                },
                grid: {
                    vertLines: { color: '#2B2B43' },
                    horzLines: { color: '#2B2B43' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: '#2B2B43',
                },
                timeScale: {
                    borderColor: '#2B2B43',
                    timeVisible: true,
                },
            });
            
            candleSeries = chart.addCandlestickSeries({
                upColor: '#00d4aa',
                downColor: '#ff6b6b',
                borderDownColor: '#ff6b6b',
                borderUpColor: '#00d4aa',
                wickDownColor: '#ff6b6b',
                wickUpColor: '#00d4aa',
            });
            
            // ãƒ‡ãƒ¼ã‚¿å–å¾—
            const [currentPrice, prediction, dates] = await Promise.all([
                fetchCandleData(),
                fetchLatestPrediction(),
                fetchAvailableDates(),
            ]);
            
            latestPrediction = prediction;
            availableDates = dates;
            currentDateIndex = 0;
            
            if (prediction) {
                updateDisplay(prediction);
            } else {
                document.getElementById('patterns-grid').innerHTML = 
                    '<div class="error">äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</div>';
            }
            
            updateNavButtons();
            chart.timeScale().fitContent();
            
            // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
            window.addEventListener('resize', function() {
                chart.applyOptions({
                    width: chartContainer.clientWidth,
                });
            });
        }
        
        // å®Ÿè¡Œ
        window.onload = function() {
            init().catch(function(err) {
                console.error('Init error:', err);
                document.getElementById('patterns-grid').innerHTML = 
                    '<div class="error">åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ' + err.message + '</div>';
            });
        };
    </script>
</body>
</html>
