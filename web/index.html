<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC AIäºˆæ¸¬ãƒãƒ£ãƒ¼ãƒˆ</title>
    <!-- Bitcoin Favicon (SVG) -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='16' fill='%23f7931a'/%3E%3Cpath d='M22.5 14.2c.3-2-1.2-3.1-3.3-3.8l.7-2.8-1.7-.4-.7 2.7c-.4-.1-.9-.2-1.4-.3l.7-2.7-1.7-.4-.7 2.8c-.4-.1-.7-.2-1.1-.3l-2.3-.6-.4 1.8s1.2.3 1.2.3c.7.2.8.6.8 1l-.8 3.2c0 0 .1 0 .2.1-.1 0-.1 0-.2 0l-1.1 4.5c-.1.2-.3.6-.8.4 0 0-1.2-.3-1.2-.3l-.8 1.9 2.2.5c.4.1.8.2 1.2.3l-.7 2.8 1.7.4.7-2.8c.5.1.9.2 1.4.3l-.7 2.8 1.7.4.7-2.8c2.9.5 5.1.3 6-2.3.7-2.1 0-3.3-1.5-4.1 1.1-.3 1.9-1 2.1-2.5zm-3.8 5.3c-.5 2.1-4 1-5.1.7l.9-3.7c1.1.3 4.7.8 4.2 3zm.5-5.4c-.5 1.9-3.4.9-4.3.7l.8-3.3c1 .2 4 .7 3.5 2.6z' fill='%23fff'/%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        h1 {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .price-info {
            text-align: right;
        }
        
        .current-price {
            font-size: 1.8rem;
            font-weight: bold;
            color: #00d4aa;
        }
        
        .timestamp {
            font-size: 0.85rem;
            color: #888;
        }
        
        /* æ—¥ä»˜ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ */
        .date-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #16213e;
            border-radius: 8px;
        }
        
        .nav-btn {
            background: #0f3460;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: background 0.2s, opacity 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .nav-btn:hover:not(:disabled) {
            background: #1a5276;
        }
        
        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .current-date {
            font-size: 1.2rem;
            font-weight: bold;
            min-width: 150px;
            text-align: center;
        }
        
        .current-date.is-latest {
            color: #00d4aa;
        }
        
        .current-date.is-latest::after {
            content: ' (æœ€æ–°)';
            font-size: 0.8rem;
            color: #888;
        }
        
        #chart-container {
            width: 100%;
            height: 500px;
            background: #16213e;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .patterns-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 900px) {
            .patterns-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .pattern-card {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #666;
        }
        
        .pattern-card.bullish {
            border-left-color: #00d4aa;
        }
        
        .pattern-card.bearish {
            border-left-color: #ff6b6b;
        }
        
        .pattern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .pattern-rank {
            background: #0f3460;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.85rem;
        }
        
        .pattern-name {
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .pattern-probability {
            font-size: 1.3rem;
            font-weight: bold;
        }
        
        .bullish .pattern-probability {
            color: #00d4aa;
        }
        
        .bearish .pattern-probability {
            color: #ff6b6b;
        }
        
        .pattern-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 10px 0;
            font-size: 0.9rem;
        }
        
        .detail-item {
            display: flex;
            justify-content: space-between;
        }
        
        .detail-label {
            color: #888;
        }
        
        .pattern-reasoning {
            font-size: 0.85rem;
            color: #aaa;
            line-height: 1.5;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
        }
        
        .summary-box {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .summary-box p {
            white-space: pre-line !important;
            line-height: 1.8;
            font-size: 14px;
            word-break: break-word;
        }
        
        .summary-box h3 {
            margin-bottom: 10px;
            color: #00d4aa;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 300px;
            color: #888;
        }
        
        .error {
            background: #3d1f1f;
            padding: 15px;
            border-radius: 8px;
            color: #ff6b6b;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.85rem;
        }
        
        footer a {
            color: #00d4aa;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸª™ BTC AIäºˆæ¸¬ãƒãƒ£ãƒ¼ãƒˆ</h1>
            <div class="price-info">
                <div class="current-price" id="current-price">--</div>
                <div class="timestamp" id="timestamp">--</div>
            </div>
        </header>
        
        <!-- æ—¥ä»˜ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ -->
        <div class="date-nav">
            <button class="nav-btn" id="prev-btn" onclick="navigatePrediction(1)">
                â† å‰æ—¥
            </button>
            <div class="current-date" id="current-date">--</div>
            <button class="nav-btn" id="next-btn" onclick="navigatePrediction(-1)">
                ç¿Œæ—¥ â†’
            </button>
        </div>
        
        <div id="chart-container"></div>
        
        <div class="summary-box" id="summary-box">
            <h3>ğŸ“Š åˆ†æã‚µãƒãƒªãƒ¼</h3>
            <p id="summary-text">èª­ã¿è¾¼ã¿ä¸­...</p>
        </div>
        
        <h2 style="margin-bottom: 15px;">ğŸ“ˆ äºˆæ¸¬ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç¢ºç‡é †ï¼‰</h2>
        <div class="patterns-grid" id="patterns-grid">
            <div class="loading">ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
        </div>
        
        <footer>
            <p>Powered by AI Analysis | <a href="https://x.com/DriftSeiya" target="_blank">@DriftSeiya</a></p>
            <p>â€» ã“ã®äºˆæ¸¬ã¯å‚è€ƒæƒ…å ±ã§ã‚ã‚Šã€æŠ•è³‡åˆ¤æ–­ã®è²¬ä»»ã¯åˆ©ç”¨è€…ã«ã‚ã‚Šã¾ã™ã€‚</p>
        </footer>
    </div>
    
    <script src="lightweight-charts.js"></script>
    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let chart = null;
        let candleSeries = null;
        let predictionLines = [];
        let availableDates = [];
        let currentDateIndex = 0;
        let latestPrediction = null;
        let lastCandleTime = null;  // æœ€å¾Œã®ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã®æ™‚åˆ»
        
        // æ—¥ä»˜ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        function formatDate(dateStr) {
            const date = new Date(dateStr);
            return date.toLocaleDateString('ja-JP', { 
                year: 'numeric', 
                month: 'numeric', 
                day: 'numeric' 
            });
        }
        
        // æ—¥ä»˜ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
        function getDateString(date) {
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // äºˆæ¸¬ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        async function navigatePrediction(direction) {
            const newIndex = currentDateIndex + direction;
            
            if (newIndex < 0 || newIndex >= availableDates.length) {
                return;
            }
            
            currentDateIndex = newIndex;
            const dateStr = availableDates[currentDateIndex];
            
            // äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            let prediction;
            if (currentDateIndex === 0) {
                prediction = latestPrediction;
            } else {
                prediction = await fetchPredictionByDate(dateStr);
            }
            
            if (prediction) {
                updateDisplay(prediction);
            }
            
            updateNavButtons();
        }
        
        // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
        function updateNavButtons() {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const dateDisplay = document.getElementById('current-date');
            
            prevBtn.disabled = currentDateIndex >= availableDates.length - 1;
            nextBtn.disabled = currentDateIndex <= 0;
            
            const currentDate = availableDates[currentDateIndex];
            dateDisplay.textContent = formatDate(currentDate);
            
            if (currentDateIndex === 0) {
                dateDisplay.classList.add('is-latest');
            } else {
                dateDisplay.classList.remove('is-latest');
            }
        }
        
        // æ—¥ä»˜åˆ¥ã®äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        async function fetchPredictionByDate(dateStr) {
            try {
                const response = await fetch(`predictions/${dateStr}.json?` + Date.now());
                if (!response.ok) return null;
                return await response.json();
            } catch (error) {
                console.error('Failed to fetch prediction:', error);
                return null;
            }
        }
        
        // åˆ©ç”¨å¯èƒ½ãªæ—¥ä»˜ä¸€è¦§ã‚’å–å¾—
        async function fetchAvailableDates() {
            try {
                const response = await fetch('predictions/index.json?' + Date.now());
                if (!response.ok) {
                    // index.jsonãŒãªã„å ´åˆã¯ä»Šæ—¥ã®æ—¥ä»˜ã®ã¿
                    return [getDateString(new Date())];
                }
                const data = await response.json();
                return data.dates || [getDateString(new Date())];
            } catch (error) {
                console.error('Failed to fetch available dates:', error);
                return [getDateString(new Date())];
            }
        }
        
        // äºˆæ¸¬ãƒ©ã‚¤ãƒ³ã‚’ã‚¯ãƒªã‚¢
        function clearPredictionLines() {
            predictionLines.forEach(line => {
                chart.removeSeries(line);
            });
            predictionLines = [];
        }
        
        // timeframeã‚’æ—¥æ•°ã«å¤‰æ›
        function timeframeToDays(timeframe) {
            if (!timeframe) return 14;  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ2é€±é–“
            
            const tf = timeframe.toLowerCase();
            
            // æ•°å€¤+å˜ä½ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
            const match = tf.match(/^(\d+)\s*(day|week|month|d|w|m)/);
            if (match) {
                const num = parseInt(match[1]);
                const unit = match[2];
                if (unit.startsWith('d')) return num;
                if (unit.startsWith('w')) return num * 7;
                if (unit.startsWith('m')) return num * 30;
            }
            
            // å˜èªãƒ‘ã‚¿ãƒ¼ãƒ³
            if (tf.includes('week')) {
                if (tf.includes('2') || tf.includes('two')) return 14;
                return 7;
            }
            if (tf.includes('month')) {
                if (tf.includes('2') || tf.includes('two')) return 60;
                if (tf.includes('3') || tf.includes('three')) return 90;
                return 30;
            }
            if (tf.includes('day')) {
                if (tf.includes('3') || tf.includes('three')) return 3;
                return 1;
            }
            
            return 14;  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        }
        
        // äºˆæ¸¬ãƒ©ã‚¤ãƒ³ã‚’è¿½åŠ 
        function addPredictionLines(patterns, currentPrice) {
            clearPredictionLines();
            
            // ãƒ­ãƒ¼ã‚½ã‚¯è¶³ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
            if (!lastCandleTime) {
                console.log('No candle data, skipping prediction lines');
                return;
            }
            
            patterns.slice(0, 10).forEach((pattern, index) => {
                const color = pattern.direction === 'bullish' ? '#00d4aa' : '#ff6b6b';
                
                if (pattern.target_price) {
                    const lineSeries = chart.addLineSeries({
                        color: color,
                        lineWidth: 2,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        priceLineVisible: false,
                        lastValueVisible: true,
                        title: '#' + pattern.rank + ' ' + pattern.pattern_name,
                    });
                    
                    // timeframeã«åŸºã¥ã„ã¦äºˆæ¸¬æœŸé–“ã‚’æ±ºå®š
                    const days = timeframeToDays(pattern.timeframe);
                    const startTime = lastCandleTime;
                    const dayInSeconds = 24 * 60 * 60;
                    const priceChange = pattern.target_price - currentPrice;
                    
                    // æ—¥ã”ã¨ã®ãƒã‚¤ãƒ³ãƒˆã§æç”»
                    const lineData = [];
                    for (let i = 0; i <= days; i++) {
                        lineData.push({
                            time: startTime + i * dayInSeconds,
                            value: currentPrice + (priceChange * i / days),
                        });
                    }
                    
                    lineSeries.setData(lineData);
                    
                    predictionLines.push(lineSeries);
                }
            });
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
        function renderPatternCards(patterns) {
            const grid = document.getElementById('patterns-grid');
            grid.innerHTML = '';
            
            patterns.forEach(pattern => {
                const card = document.createElement('div');
                card.className = 'pattern-card ' + pattern.direction;
                
                const emoji = pattern.direction === 'bullish' ? 'ğŸ“ˆ' : 'ğŸ“‰';
                const prob = (pattern.probability * 100).toFixed(0);
                const targetPrice = pattern.target_price ? '$' + pattern.target_price.toLocaleString() : '--';
                const entryPrice = pattern.key_levels && pattern.key_levels.entry ? '$' + pattern.key_levels.entry.toLocaleString() : '--';
                const stopLoss = pattern.key_levels && pattern.key_levels.stop_loss ? '$' + pattern.key_levels.stop_loss.toLocaleString() : '--';
                
                card.innerHTML = 
                    '<div class="pattern-header">' +
                        '<span class="pattern-rank">#' + pattern.rank + '</span>' +
                        '<span class="pattern-name">' + emoji + ' ' + pattern.pattern_name + '</span>' +
                        '<span class="pattern-probability">' + prob + '%</span>' +
                    '</div>' +
                    '<div class="pattern-details">' +
                        '<div class="detail-item"><span class="detail-label">ç›®æ¨™ä¾¡æ ¼</span><span>' + targetPrice + '</span></div>' +
                        '<div class="detail-item"><span class="detail-label">æœŸé–“</span><span>' + (pattern.timeframe || '--') + '</span></div>' +
                        '<div class="detail-item"><span class="detail-label">ã‚¨ãƒ³ãƒˆãƒªãƒ¼</span><span>' + entryPrice + '</span></div>' +
                        '<div class="detail-item"><span class="detail-label">ã‚¹ãƒˆãƒƒãƒ—ãƒ­ã‚¹</span><span>' + stopLoss + '</span></div>' +
                    '</div>' +
                    '<div class="pattern-reasoning">' + (pattern.reasoning || '') + '</div>';
                
                grid.appendChild(card);
            });
        }
        
        // è¡¨ç¤ºã‚’æ›´æ–°
        function updateDisplay(prediction) {
            if (!prediction) return;
            
            document.getElementById('current-price').textContent = 
                '$' + (prediction.current_price || 0).toLocaleString();
            
            if (prediction.timestamp) {
                const date = new Date(prediction.timestamp);
                document.getElementById('timestamp').textContent = 
                    'åˆ†ææ—¥æ™‚: ' + date.toLocaleString('ja-JP');
            }
            
            document.getElementById('summary-text').textContent = 
                prediction.summary || 'åˆ†æãƒ‡ãƒ¼ã‚¿ãªã—';
            
            if (prediction.patterns && prediction.patterns.length > 0) {
                renderPatternCards(prediction.patterns);
                addPredictionLines(prediction.patterns, prediction.current_price);
            }
        }
        
        // Bybitã‹ã‚‰ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆPHPãƒ—ãƒ­ã‚­ã‚·çµŒç”±ï¼‰
        async function fetchCandleData() {
            try {
                // PHPãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§Bybit APIã«ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆCORSå›é¿ï¼‰
                const response = await fetch('api/bybit_proxy.php?symbol=BTCUSDT&interval=D&limit=100');
                
                if (!response.ok) {
                    throw new Error('Proxy request failed: ' + response.status);
                }
                
                const data = await response.json();
                
                if (data.retCode === 0 && data.result && data.result.list) {
                    const candles = data.result.list.map(function(item) {
                        return {
                            time: parseInt(item[0]) / 1000,
                            open: parseFloat(item[1]),
                            high: parseFloat(item[2]),
                            low: parseFloat(item[3]),
                            close: parseFloat(item[4]),
                        };
                    }).reverse();
                    
                    if (candles.length > 0) {
                        candleSeries.setData(candles);
                        lastCandleTime = candles[candles.length - 1].time;
                        return candles[candles.length - 1].close;
                    }
                } else if (data.error) {
                    console.error('Proxy error:', data.error);
                }
            } catch (error) {
                console.error('Failed to fetch candle data:', error);
            }
            return null;
        }
        
        // æœ€æ–°ã®äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        async function fetchLatestPrediction() {
            try {
                const response = await fetch('prediction.json?' + Date.now());
                if (!response.ok) throw new Error('Prediction data not found');
                return await response.json();
            } catch (error) {
                console.error('Failed to fetch prediction data:', error);
                return null;
            }
        }
        
        // åˆæœŸåŒ–
        async function init() {
            const chartContainer = document.getElementById('chart-container');
            
            // ãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿ç¢ºèª
            if (typeof LightweightCharts === 'undefined') {
                document.getElementById('patterns-grid').innerHTML = 
                    '<div class="error">ãƒãƒ£ãƒ¼ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</div>';
                return;
            }
            
            // ãƒãƒ£ãƒ¼ãƒˆåˆæœŸåŒ–
            chart = LightweightCharts.createChart(chartContainer, {
                layout: {
                    background: { color: '#16213e' },
                    textColor: '#d1d4dc',
                },
                grid: {
                    vertLines: { color: '#2B2B43' },
                    horzLines: { color: '#2B2B43' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: '#2B2B43',
                },
                timeScale: {
                    borderColor: '#2B2B43',
                    timeVisible: true,
                },
            });
            
            candleSeries = chart.addCandlestickSeries({
                upColor: '#00d4aa',
                downColor: '#ff6b6b',
                borderDownColor: '#ff6b6b',
                borderUpColor: '#00d4aa',
                wickDownColor: '#ff6b6b',
                wickUpColor: '#00d4aa',
            });
            
            // ãƒ‡ãƒ¼ã‚¿å–å¾—
            const [currentPrice, prediction, dates] = await Promise.all([
                fetchCandleData(),
                fetchLatestPrediction(),
                fetchAvailableDates(),
            ]);
            
            latestPrediction = prediction;
            availableDates = dates;
            currentDateIndex = 0;
            
            if (prediction) {
                updateDisplay(prediction);
            } else {
                document.getElementById('patterns-grid').innerHTML = 
                    '<div class="error">äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</div>';
            }
            
            updateNavButtons();
            
            // ãƒãƒ£ãƒ¼ãƒˆã®è¡¨ç¤ºç¯„å›²ã‚’æœ€é•·ã®äºˆæ¸¬æœŸé–“ã¾ã§æ‹¡å¼µ
            let maxDays = 14;  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
            if (prediction && prediction.patterns) {
                prediction.patterns.forEach(p => {
                    const days = timeframeToDays(p.timeframe);
                    if (days > maxDays) maxDays = days;
                });
            }
            const futureTime = lastCandleTime + maxDays * 24 * 60 * 60;
            chart.timeScale().setVisibleRange({
                from: lastCandleTime - 90 * 24 * 60 * 60,  // éå»90æ—¥
                to: futureTime,  // äºˆæ¸¬æœŸé–“ã®æœ€é•·ã¾ã§
            });
            
            // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
            window.addEventListener('resize', function() {
                chart.applyOptions({
                    width: chartContainer.clientWidth,
                });
            });
        }
        
        // å®Ÿè¡Œ
        window.onload = function() {
            init().catch(function(err) {
                console.error('Init error:', err);
                document.getElementById('patterns-grid').innerHTML = 
                    '<div class="error">åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ' + err.message + '</div>';
            });
        };
    </script>
</body>
</html>
